{
  "name": "Plat4m",
  "tagline": "Plat4m is a C++ library that provides abstraction for the main elements of an embedded software application including core system functionality, peripherals, and subsystems.",
  "body": "### FAQ\r\n__*Doesn't C++ add too much overhead for embedded systems?*__\r\n\r\nC++ doesn't force you to incur overhead, no. In fact, most C code can be compiled with a C++ compiler and the result would look the same in most cases. However, certain features of C++ (like virtual functions, templates, and exceptions) will add varying amounts of overhead, depending on usage. To keep things simple and deterministic, Plat4m doesn't use exceptions, RTTI, or STL (Standard Template Library). Think of it as C++ lite.\r\n\r\n__*If you're not using exceptions, RTTI, or STL, aren't you basically just using C?*__\r\n\r\nC++ has many other nice features over C, including classes, templates, better type safety, namespaces, etc.\r\n\r\n__*Can't you do object oriented programming in C?*__\r\n\r\nSort of, but it won't be pretty or safe. While you can create handles to structures with function tables in C, the resultant code is much more exposed than creating a class in C++ and proper initialization (via a constructor) can't be guaranteed. Also, polymorphism using this method makes things exponentially worse.\r\n\r\n__*Don't C++ objects require dynamic memory allocation?*__\r\n\r\nNo, and this is where some people get confused. C++ doesn't require you to dynamically allocate memory when instantiating objects. It's perfectly legal to put objects in RAM:\r\n```c++\r\nstatic Object object;\r\n```\r\nor on the stack:\r\n```c++\r\n{\r\n    Object object;\r\n}\r\n```\r\nThe 'new' operator isn't required. However, the MemoryAllocationLite driver allows for easy dynamic memory allocation without de-allocation (sometimes called a \"never-freed\" heap).",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}